Declaring routes
We declare the pages in our app using the BrowserRouter and Route components. BrowserRouter is the top-level component and this looks for Route components beneath it to determine all the different page paths.

We are going to declare some pages in our app using BrowserRouter and Route later in this section, but before that we need to create our first two pages. This first page is going to contain the list of our React tools that we are going to sell in our shop. We use the following steps to create our pages:

So, let's start by creating the data for our list of tools by creating a ProductsData.ts file with the following content:
export interface IProduct {
  id: number;
  name: string;
  description: string;
  price: number;
}

export const products: IProduct[] = [
  {
    description:
      "A collection of navigational components that compose  
       declaratively with your app",
    id: 1,
    name: "React Router",
    price: 8
  },
  {
    description: "A library that helps manage state across your app",
    id: 2,
    name: "React Redux",
    price: 12
  },
  {
    description: "A library that helps you interact with a GraphQL backend",
    id: 3,
    name: "React Apollo",
    price: 12
  }
];
Let's create another file called ProductsPage.tsx containing the following to import React as well as our data:
import * as React from "react";
import { IProduct, products } from "./ProductsData";
We are going to reference the data in our component state, so let's create an interface for this:
interface IState {
  products: IProduct[];
}
Let's move on to create our class component called ProductsPage, initializing the state to an empty array:
class ProductsPage extends React.Component<{}, IState> {
  public constructor(props: {}) {
    super(props);
    this.state = {
      products: []
    };
  }
}

export default ProductsPage;
Let's now implement the componentDidMount life cycle method and set the data to the products array from ProductData.ts:
public componentDidMount() {
  this.setState({ products });
}
Moving on to implementing the render method, let's welcome our users and set out the products in a list:
public render() {
  return (
    <div className="page-container">
      <p>
        Welcome to React Shop where you can get all your tools for ReactJS!
      </p>
      <ul className="product-list">
        {this.state.products.map(product => (
          <li key={product.id} className="product-list-item">
           {product.name}
          </li>
        ))}
      </ul>
    </div>
  );
}
We have used the map function in the products array to iterate through the elements and produce a list item tag, li, for each product. We need to give each li a unique key attribute to help React manage any changes to the list items, which in our case is the id product.

We've referenced some CSS classes, so let's add these to index.css:
.page-container {
 text-align: center;
 padding: 20px;
 font-size: large;
}

.product-list {
 list-style: none;
 margin: 0;
 padding: 0;
}

.product-list-item {
 padding: 5px;
}
Let's implement our second page now, which is going to be an admin panel. So, let's create a file called AdminPage.tsx with the following function component inside:
import * as React from "react";

const AdminPage: React.SFC = () => {
  return (
    <div className="page-container">
      <h1>Admin Panel</h1>
      <p>You should only be here if you have logged in</p>
    </div>
  );
};

export default AdminPage;
Now that we have two pages in our shop, we can declare our two routes to them. Let's create a file called Routes.tsx with the following content to import React, the BrowserRouter and Route components from React Router, and our two pages:
import * as React from "react";
import { BrowserRouter as Router, Route } from "react-router-dom";

import AdminPage from "./AdminPage";
import ProductsPage from "./ProductsPage";
We have renamed BrowserRouter to Router in the import statement to save a few keystrokes.

Let's go on to implement a function component containing our two routes:
const Routes: React.SFC = () => {
  return (
    <Router>
      <div>
        <Route path="/products" component={ProductsPage} />
        <Route path="/admin" component={AdminPage} />
      </div>
    </Router>
  );
};

export default Routes;
During rendering, if the path in a Route component matches the current path, the component will be rendered, and if not, null will be rendered. In our example, ProductPage will be rendered if the path is "/products" and AdminPage will be rendered if the path is "/admin".
The following is the final step to render our Routes as the root component in index.tsx:
import * as React from "react";
import * as ReactDOM from "react-dom";
import "./index.css";
import Routes from "./Routes";

ReactDOM.render(<Routes />, document.getElementById("root") as HTMLElement);
We should now be able to run our app:
npm start
The app will probably start on the root page, which will be blank because that path doesn't point to anything.

If we change the path to "/products", our product list should render the following: