Discriminated union pattern
The discriminated union pattern allows us to handle the logic for different union types.

Let's go through an example:

Let's first create three interfaces to represent a textbox, a date picker, and a number slider:
interface ITextbox {
  control: "Textbox";
  value: string;
  multiline: boolean;
}

interface IDatePicker {
  control: "DatePicker";
  value: Date;
}

interface INumberSlider {
  control: "NumberSlider";
  value: number;
}
They all have a property called control, which will be the discriminant in the pattern.

Let's move on to combine these interfaces into a union type called Field:
type Field = ITextbox | IDatePicker | INumberSlider;
So, we can create union types from any types, and not just string literals. In this case, we have created a union type from three interfaces.

Let's now create a function to initialize the value in the Field type:
function intializeValue(field: Field) {
  switch (field.control) {
    case "Textbox":
      field.value = "";
      break;
    case "DatePicker":
      field.value = new Date();
      break;
    case "NumberSlider":
      field.value = 0;
      break;
    default:
      const shouldNotReach: never = field;
  }
}
The value we need to set depends on the discriminant property, control. So, we have used a switch statement to branch on this property.

The default branch in the switch statement is where things get interesting. This branch should never be reached, so we have put a statement with the never type in that branch. We'll see the value of doing this after the next steps.

Let's pretend time has passed and we have a new requirement for checkbox fields. Let's implement an interface for this:
interface ICheckbox {
  control: "Checkbox";
  value: boolean;
}
Let's also add this to the union Field type:
type Field = ITextbox | IDatePicker | INumberSlider | ICheckbox;
We'll immediately see that our initializeValue function throws a compilation error on the never declaration:



This is very valuable because the never statement ensures we don't forget to add a branch of code for the new checkbox requirement.

So, let's go and implement this additional branch for the "Checkbox" field:
function intializeValue(field: Field) {
  switch (field.control) {
    case "Textbox":
      field.value = "";
      break;
    case "DatePicker":
      field.value = new Date();
      break;
    case "NumberSlider":
      field.value = 0;
      break;
    case "Checkbox":
      field.value = false;
      break;
    default:
      const shouldNotReach: never = field;
  }
}
So, union types allow us to combine any types together to form another type. This allows us to create stricter types, particularly when working with strings. The discriminated union pattern allows us to have branches of logic for different types in t